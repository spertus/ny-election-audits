---
title: "New York Audit Algorithm Analysis"
author: "Jacob Spertus and Amanda Glazer"
date: "10/15/2019"
output:
  html_document:
    df_print: paged
---


```{r setup, include=FALSE}
library(tidyverse)
library(Matrix)
seed <- 1337
set.seed(seed)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

This notebook analyzes the current law in New York through simulations based on historic election returns at the machine level.

The original law can be found [here](https://govt.westlaw.com/nycrr/Document/I5c54c4e18b2e11dfbe5dec62e7eacc45?viewType=FullText&originationContext=documenttoc&transitionType=CategoryPageItem&contextData=(sc.Default)).
*Note: part h of the law indicates that county election boards can always proceed to recount at their discretion*

A summary of the law can be found at <http://www.ncsl.org/research/elections-and-campaigns/post-election-audits635926066.aspx>

# NY's auditing algorithm

Summarizing the above into an algorithm, the audits proceed as follows:

1. For each county, select uniformly at random no less than 3% of each type of voting machine or system used
    a) Manually tabulate ballots from the VVPAT from selected machines
    b) On selected machines, compare manual tabulations to machine tabulations, and report any discrepancies
         i) If any (>= 1) discrepancies are found on a machine, recount all ballots from that machine.
    c) If any of the following apply expand the audit (proceed to 2), else end audit:
         i) any one or more discrepancies between the confirming manual counts and the original machine or system electronic counts, which taken together, would alter the vote share of any candidate, question or proposal by 0.1 percent or more of the hand counted votes for respective contests, questions, or proposals in the entire sample
         ii) discrepancies of any amount are detected between the confirming manual count and the original machine or system electronic count from at least 10 percent of the machines or systems initially audited then the board or bipartisan team appointed by such board shall manually count the votes recorded on all the voter verifiable paper audit trail records from no less than an additional five percent of each type of the same type of voting machine or system which contains any such discrepancy or discrepancies
2. Sample 5% of machines uniformly at random and repeat 1b/c, considering the additional 5% sample as well as the original 3% sample (expanded to be 8% of all machines).
3. If 2 indicates expansion is warranted per 1c, sample 12% of machines uniformly at random (to expand to 20% of all machines) and repeat 1b/c
4. If 3 indicates expansion is warranted proceed to full hand recount


# A brief critique of the algorithm

In the worst case scenario, if discrepancies in a county are concentrated on one machine within one system, then this auditing procedure has only a 3\% chance of catching the discrepancy. The more machines that have a discrepancy between true and reported outcomes, the more likely it is that this audit catches the discrepancy. However, if discrepancies are concentrated around a few machines then it is very unlikely that this audit will catch them. 

The auditing procedure gives no lower bound on the probability that a wrong outcome will be corrected (unlike a risk limiting audit which does). Since the audit rules are public knowledge, an intelligent hacker could change the results of an election by concentrating discrepancies on as few machines as possible, leading to a very small probability of detection under this audit procedure. 

There are scenarios where this audit procedure could lead to a correctly reported outcome being overturned for an incorrect outcome. Consider the toy example with 3 counties where Amanda is reported to win the election with 47 votes and Jake is reported to lose the election with 35 votes. The true vote tally still reveals Amanda as the winner but she really only received 45 votes and Jake received 42 votes. In county A, the reported (true) votes are 10 (10) for Amanda and 5 (5) for Jake. In county B, the reported (true) votes are 5 (10) for Amanda and 10 (5) for Jake. In county C, the reported (true) votes are 32 (25) for Amanda and 25 (32) for Jake. In county A the votes were tallied correctly, but they were not in counties B and C. If the audit corrects the discrepancy in county C but not in county B, this would lead to the "corrected" tally of 40 votes for Amanda and 47 votes for Jake. The audit now declares Jake the winner, however this is incorrect. The audit has rendered a correct outcome wrong.

# The audit as a function

```{r audit function}
# function to sample more machines
sample_machines <- function(true_counts, reported_counts, machine_types, escalation_prop, ignore = NULL){
    unique_machine_types <- unique(machine_types)
    handcount_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    reported_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    positive_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    negative_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    prop_machine_discrepancy <- rep(0, length(unique_machine_types))
    #save and return sample index to avoid duplicating samples
    index_memory <- c()
    for(i in 1:length(unique_machine_types)){
      index <- which(machine_types == unique_machine_types[i])
      if(!is.null(ignore)){
        index <- index[-which(index == ignore)]
      }
      sample_size <- ceiling(escalation_prop * length(index))
      machines_sampled <- base::sample(index, size = sample_size, replace = FALSE)
      index_memory <- c(index_memory, machines_sampled)
      #specifiying drop = FALSE prevents R from turning a single row (if one machine is sampled) into a vector
      handcount_samples <- true_counts[machines_sampled,, drop = FALSE]
      reported_samples <- reported_counts[machines_sampled,, drop = FALSE]
      discrepancies <- handcount_samples - reported_samples
      # get number of machines with discrepancies
      num_machine_discrepancy <- nnzero(rowSums(abs(discrepancies)))
      # calculate proportion of sampled machines with discrepancies
      prop_machine_discrepancy[i] <- num_machine_discrepancy/sample_size
      #total handcounts within each machine type
      handcount_samples_type[i,] <- colSums(handcount_samples)
      reported_samples_type[i,] <- colSums(reported_samples)
      #pmax takes the maximum of it's left argument (the discrepancies matrix) and it's right argument, effectively rounding negatives up to 0 or vice versa 
      positive_discrepancies_type[i,] <- colSums(pmax(discrepancies, 0))
      negative_discrepancies_type[i,] <- colSums(pmin(discrepancies, 0))
    }
    list(handcount_samples_type = handcount_samples_type, 
        reported_samples_type = reported_samples_type,
        positive_discrepancies_type = positive_discrepancies_type, 
        negative_discrepancies_type = negative_discrepancies_type,
        prop_machine_discrepancy = prop_machine_discrepancy, 
        sampled_machines = index_memory)
}

#function to implement auditing algorithm given machine level returns from a single contest in a single county. function can only be used if the true counts as would be discovered by a manual tally are known for every machine, i.e. a simulated situation.
#input: 
#true_counts = a matrix with a row for each machine and a column for each candidate. Reflects the true counts that would be revealed by a manual tabulation. These are sampled.
#reported_counts = a matrix with a row for each machine and a column for each candidate. These are machine counts that contribute to the original reported outcome. These are compared to sampled true_counts.
#machine_types = a vector coding the type of each machine. Can be numeric or characters. Should be the same length as the number of rows in true_counts and reported_counts
audit_results <- function(true_counts, reported_counts, machine_types){
  unique_machine_types <- unique(machine_types)
  #containers for totals and discrepancies from sampled machines; there is a row for each machine, each column represents a different candidate
  #the law stipulates that the audit escalates if any combination of votes would cause a discrepancy of .1% of the original total. The worst case combinations of votes are the sums of all positive votes and all negative votes (such that discrepancies that go different ways don't cancel each other)
  # Sample 3% of machines
  initial_sample <- sample_machines(true_counts, reported_counts, machine_types, 0.03)

  initial_sample_index <- initial_sample$sampled_machines
    
  initial_positive_discrepancies <- colSums(initial_sample$positive_discrepancies_type)
  initial_negative_discrepancies <- colSums(initial_sample$negative_discrepancies_type)

  
  #compare total votes from handcounts to total reported votes (summed across machines)
  initial_handcount_totals <- colSums(initial_sample$handcount_samples_type)
  initial_reported_totals <- colSums(initial_sample$reported_samples_type)
  
  proportion_different_positive <- abs((initial_positive_discrepancies) / initial_handcount_totals)
  proportion_different_negative <- abs((initial_negative_discrepancies) / initial_handcount_totals)
  
  #escalate audit if discrepancies would shift total vote share by more than .001 for any candidate (question, proposal, etc) or 10% of machines have a discrepancy
  if(max(c(proportion_different_negative, proportion_different_positive)) > .001 | max(initial_sample$prop_machine_discrepancy) > 0.10){
    second_sample <- sample_machines(true_counts, reported_counts, machine_types, 0.05, ignore = initial_sample_index)
    
    second_sample_index <- second_sample$sampled_machines
    
    second_positive_discrepancies <- colSums(second_sample$positive_discrepancies_type)
    second_negative_discrepancies <- colSums(second_sample$negative_discrepancies_type)
  
    #compare total votes from handcounts to total reported votes (summed across machines)
    second_handcount_totals <- colSums(second_sample$handcount_samples_type)
    second_reported_totals <- colSums(second_sample$reported_samples_type)
    
    #combine the intial sample of 3% of machines with the additional 5% sample
    combined_handcount_totals <- initial_handcount_totals + second_handcount_totals
    combined_reported_totals <- initial_reported_totals + second_reported_totals
    
    combined_positive_discrepancies <- initial_positive_discrepancies + second_positive_discrepancies
    combined_negative_discrepancies <- initial_negative_discrepancies + second_negative_discrepancies
    
    proportion_different_positive <- abs((combined_positive_discrepancies) / combined_handcount_totals)
    proportion_different_negative <- abs((combined_negative_discrepancies) / combined_handcount_totals)
    
    if(max(c(proportion_different_positive, proportion_different_negative)) > .001 | max(second_sample$prop_machine_discrepancy) > 0.10){
      third_sample <- sample_machines(true_counts, reported_counts, machine_types, 0.12, ignore = c(initial_sample_index, second_sample_index))
      third_positive_discrepancies <- colSums(third_sample$positive_discrepancies_type)
      third_negative_discrepancies <- colSums(third_sample$negative_discrepancies_type)
    
      #compare total votes from handcounts to total reported votes (summed across machines)
      third_handcount_totals <- colSums(third_sample$handcount_samples_type)
      third_reported_totals <- colSums(third_sample$reported_samples_type)
      
      #combine the initial sample and escalation with a third escalation 
      combined_handcount_totals <- initial_handcount_totals + second_handcount_totals + third_handcount_totals
      combined_reported_totals <- initial_reported_totals + second_reported_totals + third_reported_totals
      
      combined_positive_discrepancies <- initial_positive_discrepancies + second_positive_discrepancies + third_positive_discrepancies
      combined_negative_discrepancies <- initial_negative_discrepancies + second_negative_discrepancies + third_negative_discrepancies
      
      proportion_different_positive <- abs((combined_positive_discrepancies) / combined_handcount_totals)
      proportion_different_negative <- abs((combined_negative_discrepancies) / combined_handcount_totals)
      
      if(max(c(proportion_different_positive, proportion_different_negative)) > .001 | max(third_sample$prop_machine_discrepancy) > 0.10){
        return("Proceed to full hand count")
      } else {
        return("Audit done; results confirmed")
      }
    } else {
      return("Audit done; results confirmed")
    }
    
  } else {
    return("Audit done; results confirmed")
  }
}
```

First we run a very simple unit test of the function by feeding it an election that should definitely be confirmed (the reported and true results are exactly the same), and one that should definitely be flagged as wrong (there are 1% discrepancies on every machine).

```{r test function}
test_true_counts <- matrix(c(1000,1500), nrow = 50, ncol = 2, byrow = TRUE)
#give one % of votes for candidate 1 to candidate 2
#spread exactly evenly across machines
#should lead to a full hand count every time
difference <- ceiling(.01 * test_true_counts[,1])
discrepancy_matrix <- matrix(c(-difference, difference), nrow = nrow(test_true_counts), ncol = ncol(test_true_counts))
test_reported_counts <- test_true_counts + discrepancy_matrix
test_machine_types <- c(rep("DRE", 25), rep("OS", 25))

#the above should lead to a full hand count
result_wrong <- audit_results(true_counts = test_true_counts, reported_counts = test_reported_counts, machine_types = test_machine_types)

#the below should be confirmed as true and reported counts are exactly the same
result_right <- audit_results(true_counts = test_true_counts, reported_counts = test_true_counts, machine_types = test_machine_types)

ifelse(result_wrong == "Proceed to full hand count" & result_right == "Audit done; results confirmed", "Works for both correct and discrepant elections", "Something is wrong.")
```


# Simulations 

For our simulations we consider NY precinct level data from the 2016 presidential election. Since we are not able to acquire machine level data, we will work at the precinct level instead, sampling precincts instead of machines and conducting the audits as though precincts are machines. 

```{r load data}
# Load NY 2016 Presidential Election Data
data <- read.csv("ny_precinct_2016_presidential.csv")
# Filter data to only look at Clinton and Trump
data <- data %>%
  filter(candidate == "Hillary Clinton" | candidate == "Donald Trump")
# Within a precinct group by candidate to make sure there are no duplicates
# All we really need is the county, precinct, and vote tally for each of the 2 candidates
data <- data %>% 
  group_by(county_fips, precinct, candidate) %>%
  summarise(votes = sum(votes))

# Look at number of precincts and votes tallies by county
county_tally <- data %>% 
  group_by(county_fips, candidate) %>% 
  summarise(num_votes = sum(votes), num_precincts = length(unique(precinct)))
county_tally
```
Consider county 36027 where Hillary Clinton won by 474 votes. If we flip the votes on just 1 machine, say City of Beacon W 1 ED 1, Trump would have been declared the winner in that county. Let's simulate what happens in this county.
```{r one machine simulation}
county_36027 <- data %>% 
  filter(county_fips == 36027) %>%
  spread(candidate, votes)
true_counts <- as.matrix(county_36027[, 3:4])
# Reported counts are true counts with the first precinct information flipped
reported_counts <- true_counts
reported_counts[1, 1] <- true_counts[1, 2]
reported_counts[1, 2] <- true_counts[1, 1]
# Audit results 1000 times and count the number of times it incorrectly confirms the results
error <- 0
for(i in 1:1000){
  audit <- audit_results(true_counts = true_counts, reported_counts = reported_counts, machine_types = rep(1, nrow(true_counts)))
  if(audit == "Audit done; results confirmed"){
    error = error + 1
  }
}
# Proportion of errors in the audit
error/1000
```
As expected, since error is concentrated to one machine, this auditing procedure incorrectly blesses the election outcome 97% of the time. 

Let's consider another scenario where for the first 15 machines we give 5% of Hillary Clinton's votes to Trump which results in Trump being incorrectly declared the winner in this county. In this scenario, the audit does *not* catch the error 64% of the time.

```{r 5% vote}
# True counts from county 36027
true_counts <- as.matrix(county_36027[, 3:4])
# Reported counts are true counts with the first 15 machines giving 5% of hillary's votes to trump
reported_counts <- true_counts
for(i in 1:15){
  reported_counts[i, 1] <- true_counts[i, 1] + ceiling(0.05 * true_counts[i, 2])
  reported_counts[i, 2] <- true_counts[i, 2] - ceiling(0.05 * true_counts[i, 2])
}
# Check that reported counts now declare Trump winner
colSums(reported_counts)
# Audit results 1000 times and count the number of times it incorrectly confirms the results
error = 0
for(i in 1:1000){
  audit <- audit_results(true_counts = true_counts, reported_counts = reported_counts, machine_types = rep(1, nrow(true_counts)))
  if(audit == "Audit done; results confirmed"){
    error = error + 1
  }
}
# Proportion of errors in the audit
error/1000
```
