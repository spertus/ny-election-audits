---
title: "New York Audit Algorithm Analysis"
author: "Jacob Spertus and Amanda Glazer"
date: "10/15/2019"
output: html_notebook
---


```{r setup, include=FALSE}
library(tidyverse)
seed <- 1337
set.seed(seed)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

This notebook analyzes the current law in New York through simulations based on historic election returns at the machine level.

The original law can be found [here](https://govt.westlaw.com/nycrr/Document/I5c54c4e18b2e11dfbe5dec62e7eacc45?viewType=FullText&originationContext=documenttoc&transitionType=CategoryPageItem&contextData=(sc.Default)).
*Note: part h of the law indicates that county election boards can always proceed to recount at their discretion*

A summary of the law can be found at <http://www.ncsl.org/research/elections-and-campaigns/post-election-audits635926066.aspx>

# NY's auditing algorithm

Summarizing the above into an algorithm, the audits proceed as follows:

1. For each county, select uniformly at random no less than 3% of each type of voting machine or system used
    a) Manually tabulate ballots from the VVPAT from selected machines
    b) On selected machines, compare manual tabulations to machine tabulations, and report any discrepancies
         i) If any (>= 1) discrepancies are found on a machine, recount all ballots from that machine.
    c) If any of the following apply expand the audit (proceed to 2), else end audit:
         i) any one or more discrepancies between the confirming manual counts and the original machine or system electronic counts, which taken together, would alter the vote share of any candidate, question or proposal by 0.1 percent or more of the hand counted votes for respective contests, questions, or proposals in the entire sample
         ii) discrepancies of any amount are detected between the confirming manual count and the original machine or system electronic count from at least 10 percent of the machines or systems initially audited then the board or bipartisan team appointed by such board shall manually count the votes recorded on all the voter verifiable paper audit trail records from no less than an additional five percent of each type of the same type of voting machine or system which contains any such discrepancy or discrepancies
2. Sample 5% of machines uniformly at random and repeat 1b/c, considering the additional 5% sample as well as the original 3% sample (expanded to be 8% of all machines).
3. If 2 indicates expansion is warranted per 1c, sample 12% of machines uniformly at random (to expand to 20% of all machines) and repeat 1b/c
4. If 3 indicates expansion is warranted proceed to full hand recount


# A brief critique of the algorithm


# The audit as a function

```{r audit function}
#function to implement auditing algorithm given machine level returns from a single contest in a single county. function can only be used if the true counts as would be discovered by a manual tally are known for every machine, i.e. a simulated situation.
#input: 
#true_counts = a matrix with a row for each machine and a column for each candidate. Reflects the true counts that would be revealed by a manual tabulation. These are sampled.
#reported_counts = a matrix with a row for each machine and a column for each candidate. These are machine counts that contribute to the original reported outcome. These are compared to sampled true_counts.
#machine_types = a vector coding the type of each machine. Can be numeric or characters. Should be the same length as the number of rows in true_counts and reported_counts
audit_results <- function(true_counts, reported_counts, machine_types){
  unique_machine_types <- unique(machine_types)
  #containers for totals and discrepancies from sampled machines; there is a row for each machine, each column represents a different candidate
  #the law stipulates that the audit escalates if any combination of votes would cause a discrepancy of .1% of the original total. The worst case combinations of votes are the sums of all positive votes and all negative votes (such that discrepancies that go different ways don't cancel each other)
  handcount_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
  reported_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
  positive_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
  negative_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
  #3% of machines of each type are to be sampled for the initial count
  #loop samples over machine types:
  for(i in 1:length(unique_machine_types)){
    index <- which(machine_types == unique_machine_types[i])
    sample_size <- ceiling(.03 * length(index))
    machines_sampled <- base::sample(index, size = sample_size, replace = FALSE)
    #specifiying drop = FALSE prevents R from turning a single row (if one machine is sampled) into a vector
    handcount_samples <- true_counts[machines_sampled,, drop = FALSE]
    reported_samples <- reported_counts[machines_sampled,, drop = FALSE]
    discrepancies <- handcount_samples - reported_samples
    
    #total handcounts within each machine type
    handcount_samples_type[i,] <- colSums(handcount_samples)
    reported_samples_type[i,] <- colSums(reported_samples)
    #pmax takes the maximum of it's left argument (the discrepancies matrix) and it's right argument, effectively rounding negatives up to 0 or vice versa 
    positive_discrepancies_type[i,] <- colSums(pmax(discrepancies, 0))
    negative_discrepancies_type[i,] <- colSums(pmin(discrepancies, 0))
  }
  
  initial_positive_discrepancies <- colSums(positive_discrepancies_type)
  initial_negative_discrepancies <- colSums(negative_discrepancies_type)
  
  #compare total votes from handcounts to total reported votes (summed across machines)
  initial_handcount_totals <- colSums(handcount_samples_type)
  initial_reported_totals <- colSums(reported_samples_type)
  
  proportion_different_positive <- abs((initial_positive_discrepancies) / initial_handcount_totals)
  proportion_different_negative <- abs((initial_negative_discrepancies) / initial_handcount_totals)
  
  #escalate audit if discrepancies would shift total vote share by more than .001 for any candidate (question, proposal, etc) 
  #ignore 1.c.ii for now because we have not specified different types of machines
  if(any(c(proportion_different_negative, proportion_different_positive) > .001)){
    handcount_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    reported_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    positive_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    negative_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
    for(i in 1:length(unique_machine_types)){
      index <- which(machine_types == unique_machine_types[i])
      sample_size <- ceiling(.05 * length(index))
      machines_sampled <- base::sample(index, size = sample_size, replace = FALSE)
      #specifiying drop = FALSE prevents R from turning a single row (if one machine is sampled) into a vector
      handcount_samples <- true_counts[machines_sampled,, drop = FALSE]
      reported_samples <- reported_counts[machines_sampled,, drop = FALSE]
      discrepancies <- handcount_samples - reported_samples
    
      #total handcounts within each machine type
      handcount_samples_type[i,] <- colSums(handcount_samples)
      reported_samples_type[i,] <- colSums(reported_samples)
      #pmax takes the maximum of it's left argument (the discrepancies matrix) and it's right argument, effectively rounding negatives up to 0 or vice versa 
      positive_discrepancies_type[i,] <- colSums(pmax(discrepancies, 0))
      negative_discrepancies_type[i,] <- colSums(pmin(discrepancies, 0))
  }
    second_positive_discrepancies <- colSums(positive_discrepancies_type)
    second_negative_discrepancies <- colSums(negative_discrepancies_type)
  
    #compare total votes from handcounts to total reported votes (summed across machines)
    second_handcount_totals <- colSums(handcount_samples_type)
    second_reported_totals <- colSums(reported_samples_type)
    
    #combine the intial sample of 3% of machines with the additional 2% sample
    combined_handcount_totals <- initial_handcount_totals + second_handcount_totals
    combined_reported_totals <- initial_reported_totals + second_reported_totals
    
    combined_positive_discrepancies <- initial_positive_discrepancies + second_positive_discrepancies
    combined_negative_discrepancies <- initial_negative_discrepancies + second_negative_discrepancies
    
    proportion_different_positive <- abs((combined_positive_discrepancies) / combined_handcount_totals)
    proportion_different_negative <- abs((combined_negative_discrepancies) / combined_handcount_totals)
    
    if(any(c(proportion_different_positive, proportion_different_negative) > .001)){
      handcount_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
      reported_samples_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
      positive_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
      negative_discrepancies_type <- matrix(0, nrow = length(unique_machine_types), ncol = ncol(true_counts))
      for(i in 1:length(unique_machine_types)){
        index <- which(machine_types == unique_machine_types[i])
        sample_size <- ceiling(.12 * length(index))
        machines_sampled <- base::sample(index, size = sample_size, replace = FALSE)
        #specifiying drop = FALSE prevents R from turning a single row (if one machine is sampled) into a vector
        handcount_samples <- true_counts[machines_sampled,, drop = FALSE]
        reported_samples <- reported_counts[machines_sampled,, drop = FALSE]
        discrepancies <- handcount_samples - reported_samples
      
        #total handcounts within each machine type
        handcount_samples_type[i,] <- colSums(handcount_samples)
        reported_samples_type[i,] <- colSums(reported_samples)
        #pmax takes the maximum of it's left argument (the discrepancies matrix) and it's right argument, effectively rounding negatives up to 0 or vice versa 
        positive_discrepancies_type[i,] <- colSums(pmax(discrepancies, 0))
        negative_discrepancies_type[i,] <- colSums(pmin(discrepancies, 0))
    }
      third_positive_discrepancies <- colSums(positive_discrepancies_type)
      third_negative_discrepancies <- colSums(negative_discrepancies_type)
    
      #compare total votes from handcounts to total reported votes (summed across machines)
      third_handcount_totals <- colSums(handcount_samples_type)
      third_reported_totals <- colSums(reported_samples_type)
      
      #combine the intial sample of 3% of machines with the additional 2% sample
      combined_handcount_totals <- initial_handcount_totals + second_handcount_totals + third_handcount_totals
      combined_reported_totals <- initial_reported_totals + second_reported_totals + third_reported_totals
      
      combined_positive_discrepancies <- initial_positive_discrepancies + second_positive_discrepancies + third_positive_discrepancies
      combined_negative_discrepancies <- initial_negative_discrepancies + second_negative_discrepancies + third_negative_discrepancies
      
      proportion_different_positive <- abs((combined_positive_discrepancies) / combined_handcount_totals)
      proportion_different_negative <- abs((combined_negative_discrepancies) / combined_handcount_totals)
      
      if(any(c(proportion_different_positive, proportion_different_negative)) > .001){
        return("Proceed to full hand count")
      } else {
        return("Audit done; results confirmed")
      }
    } else {
      return("Audit done; results confirmed")
    }
    
  } else {
    return("Audit done; results confirmed")
  }
}
```

```{r test function}
test_true_counts <- matrix(c(1000,1500), nrow = 50, ncol = 2, byrow = TRUE)
#give one % of votes for candidate 1 to candidate 2
#spread exactly evenly across machines
#should lead to a full hand count every time
difference <- ceiling(.01 * test_true_counts[,1])
discrepancy_matrix <- matrix(c(-difference, difference), nrow = nrow(test_true_counts), ncol = ncol(test_true_counts))
test_reported_counts <- test_true_counts + discrepancy_matrix
test_machine_types <- c(rep("DRE", 25), rep("OS", 25))

#the above should lead to a full hand count
result_wrong <- audit_results(true_counts = test_true_counts, reported_counts = test_reported_counts, machine_types = test_machine_types)

#the below should be confirmed as true and reported counts are exactly the same
result_right <- audit_results(true_counts = test_true_counts, reported_counts = test_true_counts, machine_types = test_machine_types)

ifelse(result_wrong == "Proceed to full hand count" & result_right == "Audit done; results confirmed", "Works for both correct and discrepant elections", "Something is wrong.")
```


# Simulations 